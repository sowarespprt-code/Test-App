<template>
  <div class="flex flex-col overflow-y-auto">
    <LayoutHeader>
      <template #left-header>
        <Breadcrumbs :items="breadcrumbs" />
      </template>
      <template #right-header>
      <Button
          label="Custom Action"
          theme="gray"
          variant="solid"
          @click="handleCustomButtonClick"
        >
          <template #prefix>
            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <path d="M12 5v14M5 12h14"/>
            </svg>
          </template>
        </Button>
        <CustomActions
          v-if="template.data?._customActions"
          :actions="template.data?._customActions"
        />
      </template>
    </LayoutHeader>
    <!-- Container -->
    <div
      class="flex flex-col gap-5 py-6 h-full flex-1 self-center overflow-auto mx-auto w-full max-w-4xl px-5"
    >
      <!-- custom fields descriptions -->
      <div v-if="Boolean(template.data?.about)" class="">
        <div class="prose-f" v-html="sanitize(template.data.about)" />
      </div>
      <!-- custom fields -->
      <div
        class="grid grid-cols-1 gap-4 sm:grid-cols-3"
        v-if="Boolean(visibleFields)"
      >
        <UniInput
          v-for="field in visibleFields"
          :key="`${field.fieldname}-${templateFields[field.fieldname]}`"
          :field="field"
          :value="templateFields[field.fieldname]"
          @change="
            (e) => handleOnFieldChange(e, field.fieldname, field.fieldtype)
          "
        />
      </div>
      <!-- existing fields -->
      <div
        class="flex flex-col"
        :class="(subject.length >= 2 || description.length) && 'gap-5'"
      >
        <div class="flex flex-col gap-2">
          <span class="block text-sm text-gray-700">
            Subject
            <span class="place-self-center text-red-500"> * </span>
          </span>
          <FormControl
            v-model="subject"
            type="text"
            placeholder="A short description"
          />
        </div>
        <SearchArticles
          v-if="isCustomerPortal"
          :query="subject"
          class="shadow"
        />
        <div v-if="isCustomerPortal">
          <h4
            v-show="subject.length <= 2 && description.length === 0"
            class="text-p-sm text-gray-500 ml-1"
          >
            Please enter a subject to continue
          </h4>
          <TicketTextEditor
            v-show="subject.length > 2 || description.length > 0"
            ref="editor"
            v-model:attachments="attachments"
            v-model:content="description"
            placeholder="Detailed explanation"
            expand
            :uploadFunction="(file:any)=>uploadFunction(file)"
          >
            <template #bottom-right>
              <Button
                label="Submit"
                theme="gray"
                variant="solid"
                :disabled="
                  $refs.editor.editor.isEmpty || ticket.loading || !subject
                "
                @click="() => ticket.submit()"
              />
            </template>
          </TicketTextEditor>
        </div>
      </div>

      <!-- for agent portal -->
      <div v-if="!isCustomerPortal">
        <TicketTextEditor
          ref="editor"
          v-model:attachments="attachments"
          v-model:content="description"
          placeholder="Detailed explanation"
          expand
        >
          <template #bottom-right>
            <Button
              label="Submit"
              theme="gray"
              variant="solid"
              :disabled="
                $refs.editor.editor.isEmpty || ticket.loading || !subject
              "
              @click="() => ticket.submit()"
            />
          </template>
        </TicketTextEditor>
      </div>
    </div>
  </div>
</template>

<script setup lang="ts">
import { LayoutHeader, UniInput } from "@/components";
import {
  handleLinkFieldUpdate,
  handleSelectFieldUpdate,
  parseField,
  setupCustomizations,
} from "@/composables/formCustomisation";
import { useAuthStore } from "@/stores/auth";
import { globalStore } from "@/stores/globalStore";
import { capture } from "@/telemetry";
import { Field } from "@/types";
import { isCustomerPortal, uploadFunction } from "@/utils";
import {
  Breadcrumbs,
  Button,
  call,
  createResource,
  FormControl,
  usePageMeta,
} from "frappe-ui";
import { useOnboarding } from "frappe-ui/frappe";
import { isEmpty } from "lodash";
import sanitizeHtml from "sanitize-html";
import { computed, onMounted, reactive, ref, nextTick } from "vue";
import { useRoute, useRouter } from "vue-router";
import SearchArticles from "../../components/SearchArticles.vue";
import TicketTextEditor from "./TicketTextEditor.vue";

interface P {
  templateId?: string;
}

const props = withDefaults(defineProps<P>(), {
  templateId: "",
});

const route = useRoute();
const router = useRouter();
const { $dialog } = globalStore();
const { updateOnboardingStep } = useOnboarding("helpdesk");
const { isManager, userId: userID } = useAuthStore();

// ============================================
// ⭐ FLAGS TO PREVENT DUPLICATE API CALLS
// ============================================
const subject = ref("");
const description = ref("");
const attachments = ref([]);
const templateFields = reactive({});
const isFetchingCustomerName = ref(false);
const isFetchingCustomerCode = ref(false);
const isFetchingProductName = ref(false);  // ← Changed from isFetchingProductCode

const template = createResource({
  url: "helpdesk.helpdesk.doctype.hd_ticket_template.api.get_one",
  makeParams: () => ({
    name: props.templateId || "Default",
  }),
  auto: true,
  onSuccess: (data) => {
    description.value = data.description_template || "";
    oldFields = window.structuredClone(data.fields || []);
    setupCustomizations(template, {
      doc: templateFields,
      call,
      router,
      $dialog,
      applyFilters,
    });
    setupTemplateFields(data.fields);
  },
});

function setupTemplateFields(fields) {
  fields.forEach((field: Field) => {
    templateFields[field.fieldname] = "";
  });
}

let oldFields = [];

function applyFilters(fieldname: string, filters: any = null) {
  const f: Field = template.data.fields.find((f) => f.fieldname === fieldname);
  if (!f) return;
  if (f.fieldtype === "Select") {
    handleSelectFieldUpdate(f, fieldname, filters, templateFields, oldFields);
  } else if (f.fieldtype === "Link") {
    handleLinkFieldUpdate(f, fieldname, filters, templateFields, oldFields);
  }
}

const customOnChange = computed(() => template.data?._customOnChange);

const visibleFields = computed(() => {
  let _fields = template.data?.fields?.filter(
    (f) => !isCustomerPortal.value || !f.hide_from_customer
  );
  if (!_fields) return [];
  return _fields.map((field) => parseField(field, templateFields));
});

//button
function handleCustomButtonClick() {
  console.log('Custom button clicked!');
  console.log('Current form data:', {
    subject: subject.value,
    description: description.value,
    templateFields: templateFields
  });
  
  $dialog({
    title: 'Custom Action',
    message: 'This is a custom button action. You can add any logic here.',
  });
}

// ============================================
// ⭐ AUTO-FETCH CUSTOMER NAME WHEN CUSTOMER CODE IS SELECTED
// ============================================
async function fetchCustomerName(customerCode) {
  if (!customerCode || isFetchingCustomerName.value) {
    return;
  }

  isFetchingCustomerName.value = true;

  try {
    console.log('Fetching customer for code:', customerCode);
    
    const result = await call('frappe.client.get_list', {
      doctype: 'HD Customer',
      filters: { custom_customercode: customerCode },
      fields: ['name', 'customer_name'],
      limit: 1
    });

    console.log('Fetch result:', result);

    if (result && result.length > 0) {
      const customer = result[0];
      
      await nextTick();
      
      templateFields.custom_customer_name = customer.name;
      
      console.log('Customer name field set to:', customer.name);
      console.log('Display will show:', customer.customer_name);
      
      await nextTick();
      
      // Fetch product name when customer is set via customer code
      fetchProductName(customer.name);
    } else {
      templateFields.custom_customer_name = '';
      templateFields.custom_product = '';
      console.warn('No customer found for code:', customerCode);
    }
  } catch (error) {
    console.error('Error fetching customer name:', error);
    templateFields.custom_customer_name = '';
    templateFields.custom_product = '';
  } finally {
    isFetchingCustomerName.value = false;
  }
}

// ============================================
// ⭐ AUTO-FETCH CUSTOMER CODE WHEN CUSTOMER NAME IS SELECTED
// ============================================
async function fetchCustomerCode(customerName) {
  if (!customerName || isFetchingCustomerCode.value) {
    return;
  }

  isFetchingCustomerCode.value = true;

  try {
    console.log('Fetching customer code for:', customerName);
    
    const result = await call('frappe.client.get_value', {
      doctype: 'HD Customer',
      filters: { name: customerName },
      fieldname: ['custom_customercode']
    });

    console.log('Fetch customer code result:', result);
    
    let customerCode = null;
    
    if (result?.message?.custom_customercode) {
      customerCode = result.message.custom_customercode;
    } else if (result?.custom_customercode) {
      customerCode = result.custom_customercode;
    }

    console.log('Extracted customer code:', customerCode);

    if (customerCode) {
      await nextTick();
      
      templateFields.custom_customercode = customerCode;
      console.log('✅ Customer code field set to:', customerCode);
      
      await nextTick();
    } else {
      templateFields.custom_customercode = '';
      console.warn('❌ No customer code found for:', customerName);
    }
  } catch (error) {
    console.error('Error fetching customer code:', error);
    templateFields.custom_customercode = '';
  } finally {
    isFetchingCustomerCode.value = false;
  }
}

// ============================================
// ⭐ NEW: AUTO-FETCH custom_productname AND SET TO custom_product
// FIXED: Fetch custom_productname (stored field) instead of custom_product (virtual field)
// ============================================
async function fetchProductName(customerName) {
  if (!customerName || isFetchingProductName.value) {
    return;
  }

  isFetchingProductName.value = true;

  try {
    console.log('Fetching product name for customer:', customerName);
    
    // ✅ FIXED: Fetch custom_productname (the actual stored field in HD Customer)
    const result = await call('frappe.client.get_value', {
      doctype: 'HD Customer',
      filters: { name: customerName },
      fieldname: ['custom_productname']  // ← Changed from 'custom_product' to 'custom_productname'
    });

    console.log('Fetch product name result:', result);
    
    let productName = null;
    
    // Handle both possible response formats from Frappe API
    if (result?.message?.custom_productname) {
      productName = result.message.custom_productname;
    } else if (result?.custom_productname) {
      productName = result.custom_productname;
    }

    console.log('Extracted product name:', productName);

    if (productName) {
      await nextTick();
      
      // Set the fetched custom_productname to custom_product field in HD Ticket
      templateFields.custom_product = productName;
      console.log('✅ custom_product field set to:', productName);
      
      await nextTick();
    } else {
      templateFields.custom_product = '';
      console.warn('❌ No product name found for customer:', customerName);
    }
  } catch (error) {
    console.error('Error fetching product name:', error);
    templateFields.custom_product = '';
  } finally {
    isFetchingProductName.value = false;
  }
}

// ============================================
// ⭐ HANDLE FIELD CHANGES WITH AUTO-FETCH TRIGGERS
// ============================================
function handleOnFieldChange(e: any, fieldname: string, fieldtype: string) {
  const newValue = e.value;
  templateFields[fieldname] = newValue;

  // 🔹 TRIGGER 1: When Customer Code changes → Auto-fetch Customer Name & Product
  if (fieldname === 'custom_customercode' && newValue) {
    console.log('Customer code changed to:', newValue);
    fetchCustomerName(newValue);  // This will also trigger fetchProductName internally
  }
  
  // 🔹 TRIGGER 2: When Customer Name changes → Auto-fetch Customer Code & Product
  if (fieldname === 'custom_customer_name' && newValue) {
    console.log('Customer name changed to:', newValue);
    fetchCustomerCode(newValue);   // Fetch customer code
    fetchProductName(newValue);    // Fetch product name
  }
  
  // Execute custom onChange functions if defined
  const fieldDependentFns = customOnChange.value?.[fieldname];
  if (fieldDependentFns) {
    fieldDependentFns.forEach((fn: Function) => {
      fn(newValue, fieldtype);
    });
  }
}

const ticket = createResource({
  url: "helpdesk.helpdesk.doctype.hd_ticket.api.new",
  debounce: 300,
  makeParams: () => ({
    doc: {
      description: description.value,
      subject: subject.value,
      template: props.templateId,
      ...templateFields,
    },
    attachments: attachments.value,
  }),
  validate: (params) => {
    const fields = visibleFields.value?.filter((f) => f.required) || [];
    const toVerify = [...fields, "subject", "description"];
    for (const field of toVerify) {
      if (isEmpty(params.doc[field.fieldname || field])) {
        return `${field.label || field} is required`;
      }
    }
  },
  onSuccess: (data) => {
    router.push({
      name: isCustomerPortal.value ? "TicketCustomer" : "TicketAgent",
      params: {
        ticketId: data.name,
      },
    });
    if (isManager) {
      updateOnboardingStep("create_first_ticket", true, false, () =>
        localStorage.setItem("firstTicket", data.name)
      );
    }
    if (isCustomerPortal.value) {
      capture("new_ticket_submitted", {
        data: {
          user: userID,
          ticketID: data.name,
          subject: subject.value,
          description: description.value,
          customFields: templateFields,
        },
      });
    }
  },
});

function sanitize(html: string) {
  return sanitizeHtml(html, {
    allowedTags: sanitizeHtml.defaults.allowedTags.concat(["img"]),
  });
}

const breadcrumbs = computed(() => {
  const items = [
    {
      label: "Tickets",
      route: {
        name: isCustomerPortal.value ? "TicketsCustomer" : "TicketsAgent",
      },
    },
    {
      label: "New Ticket",
      route: {
        name: "TicketNew",
      },
    },
  ];
  return items;
});

usePageMeta(() => ({
  title: "New Ticket",
}));

onMounted(() => {
  capture("new_ticket_page", {
    data: {
      user: userID,
    },
  });
});
</script>
